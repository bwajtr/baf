/*
 * This file is generated by jOOQ.
 */
package com.wajtr.baf.db.jooq.tables;


import com.wajtr.baf.db.jooq.Keys;
import com.wajtr.baf.db.jooq.Public;
import com.wajtr.baf.db.jooq.tables.AppUser.AppUserPath;
import com.wajtr.baf.db.jooq.tables.Tenant.TenantPath;
import com.wajtr.baf.db.jooq.tables.records.AppUserRoleTenantRecord;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.UUID;

import org.jooq.Condition;
import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.InverseForeignKey;
import org.jooq.Name;
import org.jooq.Path;
import org.jooq.PlainSQL;
import org.jooq.QueryPart;
import org.jooq.Record;
import org.jooq.SQL;
import org.jooq.Schema;
import org.jooq.Select;
import org.jooq.Stringly;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;


/**
 * Contains relation between application users and their roles in tenant. Any
 * role can be assigned to any user. User therefore can have many roles and one
 * role can be assigned to multiple users. Having tenant_id in this table also
 * makes it possible to support scenario, where single user operates within two
 * tenants and has different roles in each tenant.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class AppUserRoleTenant extends TableImpl<AppUserRoleTenantRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>public.app_user_role_tenant</code>
     */
    public static final AppUserRoleTenant APP_USER_ROLE_TENANT = new AppUserRoleTenant();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<AppUserRoleTenantRecord> getRecordType() {
        return AppUserRoleTenantRecord.class;
    }

    /**
     * The column <code>public.app_user_role_tenant.user_id</code>. User
     * participating in the relation - referencing user.app_user.id
     */
    public final TableField<AppUserRoleTenantRecord, UUID> USER_ID = createField(DSL.name("user_id"), SQLDataType.UUID.nullable(false), this, "User participating in the relation - referencing user.app_user.id");

    /**
     * The column <code>public.app_user_role_tenant.role</code>. Role of this
     * user within the tenant. Can be anything meaningful to the app.
     */
    public final TableField<AppUserRoleTenantRecord, String> ROLE = createField(DSL.name("role"), SQLDataType.CLOB.nullable(false), this, "Role of this user within the tenant. Can be anything meaningful to the app.");

    /**
     * The column <code>public.app_user_role_tenant.tenant_id</code>. Tenant id
     * for which this role assignment is relevant
     */
    public final TableField<AppUserRoleTenantRecord, UUID> TENANT_ID = createField(DSL.name("tenant_id"), SQLDataType.UUID.nullable(false).defaultValue(DSL.field(DSL.raw("current_tenant()"), SQLDataType.UUID)), this, "Tenant id for which this role assignment is relevant");

    private AppUserRoleTenant(Name alias, Table<AppUserRoleTenantRecord> aliased) {
        this(alias, aliased, (Field<?>[]) null, null);
    }

    private AppUserRoleTenant(Name alias, Table<AppUserRoleTenantRecord> aliased, Field<?>[] parameters, Condition where) {
        super(alias, null, aliased, parameters, DSL.comment("Contains relation between application users and their roles in tenant. Any role can be assigned to any user. User therefore can have many roles and one role can be assigned to multiple users. Having tenant_id in this table also makes it possible to support scenario, where single user operates within two tenants and has different roles in each tenant."), TableOptions.table(), where);
    }

    /**
     * Create an aliased <code>public.app_user_role_tenant</code> table
     * reference
     */
    public AppUserRoleTenant(String alias) {
        this(DSL.name(alias), APP_USER_ROLE_TENANT);
    }

    /**
     * Create an aliased <code>public.app_user_role_tenant</code> table
     * reference
     */
    public AppUserRoleTenant(Name alias) {
        this(alias, APP_USER_ROLE_TENANT);
    }

    /**
     * Create a <code>public.app_user_role_tenant</code> table reference
     */
    public AppUserRoleTenant() {
        this(DSL.name("app_user_role_tenant"), null);
    }

    public <O extends Record> AppUserRoleTenant(Table<O> path, ForeignKey<O, AppUserRoleTenantRecord> childPath, InverseForeignKey<O, AppUserRoleTenantRecord> parentPath) {
        super(path, childPath, parentPath, APP_USER_ROLE_TENANT);
    }

    /**
     * A subtype implementing {@link Path} for simplified path-based joins.
     */
    public static class AppUserRoleTenantPath extends AppUserRoleTenant implements Path<AppUserRoleTenantRecord> {

        private static final long serialVersionUID = 1L;
        public <O extends Record> AppUserRoleTenantPath(Table<O> path, ForeignKey<O, AppUserRoleTenantRecord> childPath, InverseForeignKey<O, AppUserRoleTenantRecord> parentPath) {
            super(path, childPath, parentPath);
        }
        private AppUserRoleTenantPath(Name alias, Table<AppUserRoleTenantRecord> aliased) {
            super(alias, aliased);
        }

        @Override
        public AppUserRoleTenantPath as(String alias) {
            return new AppUserRoleTenantPath(DSL.name(alias), this);
        }

        @Override
        public AppUserRoleTenantPath as(Name alias) {
            return new AppUserRoleTenantPath(alias, this);
        }

        @Override
        public AppUserRoleTenantPath as(Table<?> alias) {
            return new AppUserRoleTenantPath(alias.getQualifiedName(), this);
        }
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : Public.PUBLIC;
    }

    @Override
    public UniqueKey<AppUserRoleTenantRecord> getPrimaryKey() {
        return Keys.APP_USER_ROLE_PK;
    }

    @Override
    public List<ForeignKey<AppUserRoleTenantRecord, ?>> getReferences() {
        return Arrays.asList(Keys.APP_USER_ROLE_TENANT__APP_USER_ROLE_TENANT_TENANT_ID_FKEY, Keys.APP_USER_ROLE_TENANT__APP_USER_ROLE_TENANT_USER_ID_FKEY);
    }

    private transient TenantPath _tenant;

    /**
     * Get the implicit join path to the <code>public.tenant</code> table.
     */
    public TenantPath tenant() {
        if (_tenant == null)
            _tenant = new TenantPath(this, Keys.APP_USER_ROLE_TENANT__APP_USER_ROLE_TENANT_TENANT_ID_FKEY, null);

        return _tenant;
    }

    private transient AppUserPath _appUser;

    /**
     * Get the implicit join path to the <code>public.app_user</code> table.
     */
    public AppUserPath appUser() {
        if (_appUser == null)
            _appUser = new AppUserPath(this, Keys.APP_USER_ROLE_TENANT__APP_USER_ROLE_TENANT_USER_ID_FKEY, null);

        return _appUser;
    }

    @Override
    public AppUserRoleTenant as(String alias) {
        return new AppUserRoleTenant(DSL.name(alias), this);
    }

    @Override
    public AppUserRoleTenant as(Name alias) {
        return new AppUserRoleTenant(alias, this);
    }

    @Override
    public AppUserRoleTenant as(Table<?> alias) {
        return new AppUserRoleTenant(alias.getQualifiedName(), this);
    }

    /**
     * Rename this table
     */
    @Override
    public AppUserRoleTenant rename(String name) {
        return new AppUserRoleTenant(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public AppUserRoleTenant rename(Name name) {
        return new AppUserRoleTenant(name, null);
    }

    /**
     * Rename this table
     */
    @Override
    public AppUserRoleTenant rename(Table<?> name) {
        return new AppUserRoleTenant(name.getQualifiedName(), null);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public AppUserRoleTenant where(Condition condition) {
        return new AppUserRoleTenant(getQualifiedName(), aliased() ? this : null, null, condition);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public AppUserRoleTenant where(Collection<? extends Condition> conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public AppUserRoleTenant where(Condition... conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public AppUserRoleTenant where(Field<Boolean> condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public AppUserRoleTenant where(SQL condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public AppUserRoleTenant where(@Stringly.SQL String condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public AppUserRoleTenant where(@Stringly.SQL String condition, Object... binds) {
        return where(DSL.condition(condition, binds));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public AppUserRoleTenant where(@Stringly.SQL String condition, QueryPart... parts) {
        return where(DSL.condition(condition, parts));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public AppUserRoleTenant whereExists(Select<?> select) {
        return where(DSL.exists(select));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public AppUserRoleTenant whereNotExists(Select<?> select) {
        return where(DSL.notExists(select));
    }
}
