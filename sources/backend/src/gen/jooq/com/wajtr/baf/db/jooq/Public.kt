/*
 * This file is generated by jOOQ.
 */
package com.wajtr.baf.db.jooq


import com.wajtr.baf.db.jooq.tables.AppUser
import com.wajtr.baf.db.jooq.tables.AppUserRoleTenant
import com.wajtr.baf.db.jooq.tables.AuthenticateUser
import com.wajtr.baf.db.jooq.tables.FlywaySchemaHistory
import com.wajtr.baf.db.jooq.tables.MemberInvitation
import com.wajtr.baf.db.jooq.tables.PgBlockingProcesses
import com.wajtr.baf.db.jooq.tables.Product
import com.wajtr.baf.db.jooq.tables.Tenant
import com.wajtr.baf.db.jooq.tables.UserLoginLog
import com.wajtr.baf.db.jooq.tables.records.AuthenticateUserRecord

import kotlin.collections.List

import org.jooq.Catalog
import org.jooq.Configuration
import org.jooq.Field
import org.jooq.Result
import org.jooq.Table
import org.jooq.impl.DSL
import org.jooq.impl.SchemaImpl


/**
 * standard public schema
 */
@Suppress("warnings")
open class Public : SchemaImpl(DSL.name("public"), DefaultCatalog.DEFAULT_CATALOG, DSL.comment("standard public schema")) {
    companion object {

        /**
         * The reference instance of <code>public</code>
         */
        val PUBLIC: Public = Public()
    }

    /**
     * The table <code>public.app_user</code>.
     */
    val APP_USER: AppUser get() = AppUser.APP_USER

    /**
     * Contains relation between application users and their roles in tenant.
     * Any role can be assigned to any user. User therefore can have many roles
     * and one role can be assigned to multiple users. Having tenant_id in this
     * table also makes it possible to support scenario, where single user
     * operates within two tenants and has different roles in each tenant.
     */
    val APP_USER_ROLE_TENANT: AppUserRoleTenant get() = AppUserRoleTenant.APP_USER_ROLE_TENANT

    /**
     * The table <code>public.authenticate_user</code>.
     */
    val AUTHENTICATE_USER: AuthenticateUser get() = AuthenticateUser.AUTHENTICATE_USER

    /**
     * Call <code>public.authenticate_user</code>.
     */
    fun AUTHENTICATE_USER(
          configuration: Configuration
        , pEmail: String?
        , pPassword: String?
    ): Result<AuthenticateUserRecord> = configuration.dsl().selectFrom(com.wajtr.baf.db.jooq.tables.AuthenticateUser.AUTHENTICATE_USER.call(
          pEmail
        , pPassword
    )).fetch()

    /**
     * Get <code>public.authenticate_user</code> as a table.
     */
    fun AUTHENTICATE_USER(
          pEmail: String?
        , pPassword: String?
    ): AuthenticateUser = com.wajtr.baf.db.jooq.tables.AuthenticateUser.AUTHENTICATE_USER.call(
        pEmail,
        pPassword
    )

    /**
     * Get <code>public.authenticate_user</code> as a table.
     */
    fun AUTHENTICATE_USER(
          pEmail: Field<String?>
        , pPassword: Field<String?>
    ): AuthenticateUser = com.wajtr.baf.db.jooq.tables.AuthenticateUser.AUTHENTICATE_USER.call(
        pEmail,
        pPassword
    )

    /**
     * The table <code>public.flyway_schema_history</code>.
     */
    val FLYWAY_SCHEMA_HISTORY: FlywaySchemaHistory get() = FlywaySchemaHistory.FLYWAY_SCHEMA_HISTORY

    /**
     * Table holding invitations to join tenant accounts (created typically by
     * user administrators)
     */
    val MEMBER_INVITATION: MemberInvitation get() = MemberInvitation.MEMBER_INVITATION

    /**
     * The table <code>public.pg_blocking_processes</code>.
     */
    val PG_BLOCKING_PROCESSES: PgBlockingProcesses get() = PgBlockingProcesses.PG_BLOCKING_PROCESSES

    /**
     * Products definitions
     */
    val PRODUCT: Product get() = Product.PRODUCT

    /**
     * Represents a tenant (company) of the application. Almost everything in
     * database is bound to a tenant. One tenant cannot see data of other
     * tenants. It's a way how to have multiple customers inside single database
     * schema
     */
    val TENANT: Tenant get() = Tenant.TENANT

    /**
     * Table holding user login events - new record with a timestamp is added to
     * this table when any user successfully logs into the application.
     */
    val USER_LOGIN_LOG: UserLoginLog get() = UserLoginLog.USER_LOGIN_LOG

    override fun getCatalog(): Catalog = DefaultCatalog.DEFAULT_CATALOG

    override fun getTables(): List<Table<*>> = listOf(
        AppUser.APP_USER,
        AppUserRoleTenant.APP_USER_ROLE_TENANT,
        AuthenticateUser.AUTHENTICATE_USER,
        FlywaySchemaHistory.FLYWAY_SCHEMA_HISTORY,
        MemberInvitation.MEMBER_INVITATION,
        PgBlockingProcesses.PG_BLOCKING_PROCESSES,
        Product.PRODUCT,
        Tenant.TENANT,
        UserLoginLog.USER_LOGIN_LOG
    )
}
