/*
 * This file is generated by jOOQ.
 */
package com.wajtr.baf.db.jooq.tables;


import com.wajtr.baf.db.jooq.Public;
import com.wajtr.baf.db.jooq.tables.records.PgBlockingProcessesRecord;

import java.util.Collection;

import org.jooq.Condition;
import org.jooq.Field;
import org.jooq.Name;
import org.jooq.PlainSQL;
import org.jooq.QueryPart;
import org.jooq.SQL;
import org.jooq.Schema;
import org.jooq.Select;
import org.jooq.Stringly;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class PgBlockingProcesses extends TableImpl<PgBlockingProcessesRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>public.pg_blocking_processes</code>
     */
    public static final PgBlockingProcesses PG_BLOCKING_PROCESSES = new PgBlockingProcesses();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<PgBlockingProcessesRecord> getRecordType() {
        return PgBlockingProcessesRecord.class;
    }

    /**
     * The column <code>public.pg_blocking_processes.blocking_pid</code>.
     */
    public final TableField<PgBlockingProcessesRecord, Integer> BLOCKING_PID = createField(DSL.name("blocking_pid"), SQLDataType.INTEGER, this, "");

    /**
     * The column <code>public.pg_blocking_processes.blocking_user</code>.
     */
    public final TableField<PgBlockingProcessesRecord, String> BLOCKING_USER = createField(DSL.name("blocking_user"), SQLDataType.VARCHAR, this, "");

    /**
     * The column <code>public.pg_blocking_processes.blocking_query</code>.
     */
    public final TableField<PgBlockingProcessesRecord, String> BLOCKING_QUERY = createField(DSL.name("blocking_query"), SQLDataType.CLOB, this, "");

    /**
     * The column <code>public.pg_blocking_processes.blocked_pid</code>.
     */
    public final TableField<PgBlockingProcessesRecord, Integer> BLOCKED_PID = createField(DSL.name("blocked_pid"), SQLDataType.INTEGER, this, "");

    /**
     * The column <code>public.pg_blocking_processes.blocked_user</code>.
     */
    public final TableField<PgBlockingProcessesRecord, String> BLOCKED_USER = createField(DSL.name("blocked_user"), SQLDataType.VARCHAR, this, "");

    /**
     * The column <code>public.pg_blocking_processes.blocked_query</code>.
     */
    public final TableField<PgBlockingProcessesRecord, String> BLOCKED_QUERY = createField(DSL.name("blocked_query"), SQLDataType.CLOB, this, "");

    /**
     * The column <code>public.pg_blocking_processes.age</code>.
     */
    public final TableField<PgBlockingProcessesRecord, String> AGE = createField(DSL.name("age"), SQLDataType.CLOB, this, "");

    private PgBlockingProcesses(Name alias, Table<PgBlockingProcessesRecord> aliased) {
        this(alias, aliased, (Field<?>[]) null, null);
    }

    private PgBlockingProcesses(Name alias, Table<PgBlockingProcessesRecord> aliased, Field<?>[] parameters, Condition where) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.view("""
        CREATE VIEW "pg_blocking_processes" AS  SELECT kl.pid AS blocking_pid,
          ka.usename AS blocking_user,
          ka.query AS blocking_query,
          bl.pid AS blocked_pid,
          a.usename AS blocked_user,
          a.query AS blocked_query,
          to_char(age(now(), a.query_start), 'HH24h:MIm:SSs'::text) AS age
         FROM (((pg_locks bl
           JOIN pg_stat_activity a ON ((bl.pid = a.pid)))
           JOIN pg_locks kl ON (((bl.locktype = kl.locktype) AND (NOT (bl.database IS DISTINCT FROM kl.database)) AND (NOT (bl.relation IS DISTINCT FROM kl.relation)) AND (NOT (bl.page IS DISTINCT FROM kl.page)) AND (NOT (bl.tuple IS DISTINCT FROM kl.tuple)) AND (NOT (bl.virtualxid IS DISTINCT FROM kl.virtualxid)) AND (NOT (bl.transactionid IS DISTINCT FROM kl.transactionid)) AND (NOT (bl.classid IS DISTINCT FROM kl.classid)) AND (NOT (bl.objid IS DISTINCT FROM kl.objid)) AND (NOT (bl.objsubid IS DISTINCT FROM kl.objsubid)) AND (bl.pid <> kl.pid))))
           JOIN pg_stat_activity ka ON ((kl.pid = ka.pid)))
        WHERE (kl.granted AND (NOT bl.granted))
        ORDER BY a.query_start;
        """), where);
    }

    /**
     * Create an aliased <code>public.pg_blocking_processes</code> table
     * reference
     */
    public PgBlockingProcesses(String alias) {
        this(DSL.name(alias), PG_BLOCKING_PROCESSES);
    }

    /**
     * Create an aliased <code>public.pg_blocking_processes</code> table
     * reference
     */
    public PgBlockingProcesses(Name alias) {
        this(alias, PG_BLOCKING_PROCESSES);
    }

    /**
     * Create a <code>public.pg_blocking_processes</code> table reference
     */
    public PgBlockingProcesses() {
        this(DSL.name("pg_blocking_processes"), null);
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : Public.PUBLIC;
    }

    @Override
    public PgBlockingProcesses as(String alias) {
        return new PgBlockingProcesses(DSL.name(alias), this);
    }

    @Override
    public PgBlockingProcesses as(Name alias) {
        return new PgBlockingProcesses(alias, this);
    }

    @Override
    public PgBlockingProcesses as(Table<?> alias) {
        return new PgBlockingProcesses(alias.getQualifiedName(), this);
    }

    /**
     * Rename this table
     */
    @Override
    public PgBlockingProcesses rename(String name) {
        return new PgBlockingProcesses(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public PgBlockingProcesses rename(Name name) {
        return new PgBlockingProcesses(name, null);
    }

    /**
     * Rename this table
     */
    @Override
    public PgBlockingProcesses rename(Table<?> name) {
        return new PgBlockingProcesses(name.getQualifiedName(), null);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public PgBlockingProcesses where(Condition condition) {
        return new PgBlockingProcesses(getQualifiedName(), aliased() ? this : null, null, condition);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public PgBlockingProcesses where(Collection<? extends Condition> conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public PgBlockingProcesses where(Condition... conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public PgBlockingProcesses where(Field<Boolean> condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public PgBlockingProcesses where(SQL condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public PgBlockingProcesses where(@Stringly.SQL String condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public PgBlockingProcesses where(@Stringly.SQL String condition, Object... binds) {
        return where(DSL.condition(condition, binds));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public PgBlockingProcesses where(@Stringly.SQL String condition, QueryPart... parts) {
        return where(DSL.condition(condition, parts));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public PgBlockingProcesses whereExists(Select<?> select) {
        return where(DSL.exists(select));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public PgBlockingProcesses whereNotExists(Select<?> select) {
        return where(DSL.notExists(select));
    }
}
